# -*- coding: utf-8 -*-
from smartdz import models, fields, api
from smartdz.exceptions import ValidationError
import json


class DwMeetingSummary(models.Model):
    _name = 'dw.meeting.summary'
    _description = 'Meeting Summary'
    _inherit = ['mail.thread', 'mail.activity.mixin']  # Add mail.thread inheritance
    _order = 'create_date desc'

    name = fields.Char(string='Summary Title', compute='_compute_name', store=True)
    meeting_id = fields.Many2one('dw.meeting', string='Meeting', required=True, ondelete='cascade')

    # Summary content
    executive_summary = fields.Html(string='Executive Summary', tracking=True)
    key_decisions = fields.Html(string='Key Decisions', tracking=True)
    action_items_summary = fields.Html(string='Action Items Summary', tracking=True)
    participants_summary = fields.Text(string='Participants Summary')
    discussion_points = fields.Html(string='Discussion Points', tracking=True)

    # Metadata
    meeting_duration = fields.Float(string='Meeting Duration (hours)', related='meeting_id.actual_duration')
    participants_count = fields.Integer(string='Participants Count', compute='_compute_participants_count')
    actions_count = fields.Integer(string='Actions Count', compute='_compute_actions_count')

    # AI Generation metadata
    generated_by = fields.Many2one('res.users', string='Generated By', default=lambda self: self.env.user)
    generation_date = fields.Datetime(string='Generated On', default=fields.Datetime.now)
    ai_model_used = fields.Char(string='AI Model', default='Google Gemini')

    # Raw data for AI processing
    raw_notes = fields.Text(string='Raw Notes Data')
    raw_actions = fields.Text(string='Raw Actions Data')

    # Status
    state = fields.Selection([
        ('draft', 'Draft'),
        ('validated', 'Validated'),
        ('sent', 'Sent to Participants')
    ], string='Status', default='draft', tracking=True)

    @api.depends('meeting_id')
    def _compute_name(self):
        for record in self:
            if record.meeting_id:
                record.name = f"Summary: {record.meeting_id.name}"
            else:
                record.name = "Meeting Summary"

    def _compute_participants_count(self):
        for record in self:
            record.participants_count = len(record.meeting_id.participant_ids)

    def _compute_actions_count(self):
        for record in self:
            record.actions_count = self.env['dw.actions'].search_count([
                ('meeting_id', '=', record.meeting_id.id)
            ])

    def action_validate(self):
        """Validate the summary"""
        self.write({'state': 'validated'})
        # Post message to chatter
        self.message_post(
            body="Summary validated",
            message_type='notification',
            subtype_xmlid='mail.mt_note'
        )
        return True

    def action_send_to_participants(self):
        """Send summary to all participants"""
        self.ensure_one()
        template = self.env.ref('meeting_management_base.email_template_meeting_summary', raise_if_not_found=False)

        if not template:
            raise ValidationError("Email template not found!")

        sent_count = 0
        for participant in self.meeting_id.participant_ids:
            email = None
            if participant.partner_id and participant.partner_id.email:
                email = participant.partner_id.email
            elif participant.employee_id and participant.employee_id.work_email:
                email = participant.employee_id.work_email

            if email:
                template.send_mail(self.id, force_send=True, email_values={
                    'email_to': email
                })
                sent_count += 1

        self.write({'state': 'sent'})

        # Post message to chatter
        self.message_post(
            body=f"Summary sent to {sent_count} participant(s)",
            message_type='notification',
            subtype_xmlid='mail.mt_comment'
        )

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Success',
                'message': f'Summary sent to {sent_count} participants',
                'type': 'success',
            }
        }

    @api.model
    def generate_summary_data(self, meeting_id):
        """Prepare data for AI summary generation"""
        meeting = self.env['dw.meeting'].browse(meeting_id)

        # Gather all session notes
        sessions = self.env['dw.meeting.session'].search([
            ('meeting_id', '=', meeting_id)
        ])

        all_notes = []
        for session in sessions:
            if session.personal_notes:
                all_notes.append({
                    'participant': session.participant_id.name if session.participant_id else session.user_id.name,
                    'notes': session.personal_notes
                })

        # Gather all actions
        actions = self.env['dw.actions'].search([
            ('meeting_id', '=', meeting_id)
        ])

        actions_data = []
        for action in actions:
            actions_data.append({
                'title': action.name,
                'assignee': action.assignee.name if action.assignee else 'Unassigned',
                'due_date': action.dead_line.strftime('%Y-%m-%d') if action.dead_line else 'No deadline',
                'priority': action.priority,
                'status': action.status,
                'description': action.description or ''
            })

        # Gather decisions (from notes model if exists, or parse from notes)
        decisions = []
        if 'dw.meeting.decision' in self.env:
            decision_records = self.env['dw.meeting.decision'].search([
                ('meeting_id', '=', meeting_id)
            ])
            for decision in decision_records:
                decisions.append({
                    'title': decision.title if hasattr(decision, 'title') else decision.name,
                    'description': decision.description if hasattr(decision, 'description') else '',
                    'decided_by': decision.decided_by_id.name if hasattr(decision,
                                                                         'decided_by_id') and decision.decided_by_id else ''
                })

        return {
            'meeting': {
                'name': meeting.name,
                'objet': meeting.objet,
                'start_time': meeting.planned_start_datetime.strftime('%Y-%m-%d %H:%M') if meeting.planned_start_datetime else '',
                'planned_end_time': meeting.actual_end_time.strftime('%Y-%m-%d %H:%M') if meeting.actual_end_time else '',
                'duration': meeting.actual_duration,
                'agenda': meeting.subject_order,
                'participants': [p.name for p in meeting.participant_ids]
            },
            'notes': all_notes,
            'actions': actions_data,
            'decisions': decisions
        }